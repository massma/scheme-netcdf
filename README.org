* scheme-netcdf

Playing around with MIT/GNU Scheme's FFI, with the goal of getting netcdf functionality into mit-scheme.

** Prerequisites

1. netcdf libraries installed (I'm using version 4.4.1).
2. The script assumes gcc is aware of the location of netcdf headers and
   libraries.
3. MIT/GNU Scheme Version 9.2

** Build Instructions

1. clone repository
2. ~git submodule init && git submodule update~ :: load Alexey Radul's
      [[https://github.com/axch/test-manager][test-manager]] for make check.
3. ~make check~ :: builds package and runs some simple tests.

Note that everything /should/ just work if you installed MIT/GNU Scheme,
gcc, and netcdf through [[https://www.gnu.org/software/guix/][GNU Guix]]. If you do not use Guix as your package
manager, you might have to tweak the Makefile but that shouldn't be too
bad. Autotools might be added at some point, we'll see.

** Usage 
More documentation to come, also this is all still in development and
likely to change.

Make sure the repo's directory is in your library path (see --library in
[[info:mit-scheme-user#Unix%20Installation][documentation]] documentation). To load package just run below:

#+BEGIN_SRC scheme
  (load-option 'ffi)
  (c-include "netcdf")
  (load "netcdf")
#+END_SRC

*** Basic functions

- ~(make-meta filename)~ :: load metadata from filename (output
     analogous to ~ncdump -h~).

- ~(make-var-data meta varname)~ :: load data variable structure
     (defined by the string ~varname~) from dataset described by meta
     (loaded with ~make-meta~).

- ~(get-keys structure)~ :: get list of all keys in ~structure~ .

- ~(get key structure)~ :: select element defined by ~key~ in
     ~structure~ .

- ~(index coords variable)~ :: return a new data variable structure
     indexed by ~coords~. Coords should be list corresponding to the
     number of dimensions of variable. Each element of the coords list
     can be a symbol ~'all~ (for a slice with all coordinates of that
     dimension), a pair [~(low . high)~] for a slice of all coordinates
     between low and high, or a number, which indexed a single
     coordinate of that dimension. Note that coordinates do not have to
     be exact. The software will find the nearest coordinate value in
     the case of a single coordinate, and in the case of a ~(low
     . high)~ slice will take all coordinate between low and high,
     inclusive of low and high in the case that that coordinates exist
     that are equal to low and high. An example might be appropriate,
     see below.

** Index Example

Say we have a data variable structure called ~data~ of 3 dimensions
('x', 'y', 'z'), with each dimension having 5 coordinates equal to ~(0 1 2 3 4)~. 

Then the index procedure:

~(define new-data (index '(all (1 . 3) 0) data)~

Would set ~new-data~ to a new data structure of 3 dimensions, of shape 5x3x1. This
is represented internally as a structure of shape 5x3, but the last
coordinate is preserved in new-data's structural element
~single-dimensions~. So this new data structure would have the following
characteristics:


#+BEGIN_SRC scheme
  (get 'shape new-data)
  ;; (5 3)
  (get 'single-dimensions new-data)
  ;; ('z'  0)
  (get 'dimensions new-data)
  ;; (('x' (0 1 2 3 4 5)) ('y' (1 2 3)))
#+END_SRC



